{
  "paragraphs": [
    {
      "text": "%md\n\n### DataFrame\n- Partitioning of the DataFrame defines the layout of the DataFrame or Dataset’s physical distribution across the cluster. \n- You can set partition to be based on values in a certain column or nondeterministically.",
      "user": "anonymous",
      "dateUpdated": "Aug 5, 2018 4:22:42 PM",
      "config": {
        "colWidth": 12.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003ch3\u003eDataFrame\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ePartitioning of the DataFrame defines the layout of the DataFrame or Dataset’s physical distribution across the cluster.\u003c/li\u003e\n\u003cli\u003eYou can set partition to be based on values in a certain column or nondeterministically.\u003c/li\u003e\n\u003c/ul\u003e\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533485982293_-1802901344",
      "id": "20180805-161942_1374390528",
      "dateCreated": "Aug 5, 2018 4:19:42 PM",
      "dateStarted": "Aug 5, 2018 4:22:42 PM",
      "dateFinished": "Aug 5, 2018 4:22:42 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%sh\n\nif [ -e /tmp/2015-summary.json ]\nthen\n    rm -f /tmp/2015-summary.json\nfi\n\nwget https://raw.githubusercontent.com/databricks/Spark-The-Definitive-Guide/master/data/flight-data/json/2015-summary.json -O /tmp/2015-summary.json\n\nhdfs dfs -rm -f /tmp/2015-summary.json\n\n# Move downloaded JSON file from local storage to HDFS\nhdfs dfs -put /tmp/2015-summary.json /tmp\n",
      "user": "anonymous",
      "dateUpdated": "Aug 5, 2018 4:29:01 PM",
      "config": {
        "colWidth": 12.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "sh",
          "editOnDblClick": false
        },
        "editorMode": "ace/mode/sh"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "--2018-08-05 16:29:01--  https://raw.githubusercontent.com/databricks/Spark-The-Definitive-Guide/master/data/flight-data/json/2015-summary.json\nResolving raw.githubusercontent.com (raw.githubusercontent.com)... 151.101.0.133, 151.101.64.133, 151.101.128.133, ...\nConnecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.0.133|:443... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 21368 (21K) [text/plain]\nSaving to: ‘/tmp/2015-summary.json’\n\n     0K .......... ..........                                 100%  900K\u003d0.02s\n\n2018-08-05 16:29:01 (900 KB/s) - ‘/tmp/2015-summary.json’ saved [21368/21368]\n\n18/08/05 16:29:04 INFO fs.TrashPolicyDefault: Moved: \u0027hdfs://sandbox-hdp.hortonworks.com:8020/tmp/2015-summary.json\u0027 to trash at: hdfs://sandbox-hdp.hortonworks.com:8020/user/zeppelin/.Trash/Current/tmp/2015-summary.json\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533486162147_25268899",
      "id": "20180805-162242_159510996",
      "dateCreated": "Aug 5, 2018 4:22:42 PM",
      "dateStarted": "Aug 5, 2018 4:29:01 PM",
      "dateFinished": "Aug 5, 2018 4:29:09 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "val flightData2015 \u003d spark.read.format(\"json\").load(\"/tmp/2015-summary.json\")\n\nflightData2015.printSchema()\n",
      "user": "anonymous",
      "dateUpdated": "Aug 5, 2018 4:29:42 PM",
      "config": {
        "colWidth": 12.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false
        },
        "editorMode": "ace/mode/scala"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "flightData2015: org.apache.spark.sql.DataFrame \u003d [DEST_COUNTRY_NAME: string, ORIGIN_COUNTRY_NAME: string ... 1 more field]\nroot\n |-- DEST_COUNTRY_NAME: string (nullable \u003d true)\n |-- ORIGIN_COUNTRY_NAME: string (nullable \u003d true)\n |-- count: long (nullable \u003d true)\n\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533486170339_58573487",
      "id": "20180805-162250_645725983",
      "dateCreated": "Aug 5, 2018 4:22:50 PM",
      "dateStarted": "Aug 5, 2018 4:29:42 PM",
      "dateFinished": "Aug 5, 2018 4:29:43 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\n- A schema defines the column names and types of a DataFrame. \n- We can either let a data source define the schema (called schema-on-read) or we can define it explicitly ourselves.\n\n\u003caside class\u003d\"warning\"\u003e\n    For ad hoc analysis, schema-on-read usually works just fine (although at times it can be a bit slow with plain-text file formats like CSV or JSON). However, this can also lead to precision issues like a long type incorrectly set as an integer when reading in a file. When using Spark for production Extract, Transform, and Load (ETL), it is often a good idea to define your schemas manually, especially when working with untyped data sources like CSV and JSON because schema inference can vary depending on the type of data that you read in.\n\u003c/aside\u003e",
      "user": "anonymous",
      "dateUpdated": "Aug 5, 2018 4:32:20 PM",
      "config": {
        "colWidth": 12.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": false,
        "tableHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cul\u003e\n\u003cli\u003eA schema defines the column names and types of a DataFrame.\u003c/li\u003e\n\u003cli\u003eWe can either let a data source define the schema (called schema-on-read) or we can define it explicitly ourselves.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003caside class\u003d\"warning\"\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eFor ad hoc analysis, schema-on-read usually works just fine (although at times it can be a bit slow with plain-text file formats like CSV or JSON). However, this can also lead to precision issues like a long type incorrectly set as an integer when reading in a file. When using Spark for production Extract, Transform, and Load (ETL), it is often a good idea to define your schemas manually, especially when working with untyped data sources like CSV and JSON because schema inference can vary depending on the type of data that you read in.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/aside\u003e\u003c/p\u003e\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533486328644_-1122038642",
      "id": "20180805-162528_456809827",
      "dateCreated": "Aug 5, 2018 4:25:28 PM",
      "dateStarted": "Aug 5, 2018 4:32:14 PM",
      "dateFinished": "Aug 5, 2018 4:32:14 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "spark.read.format(\"json\").load(\"/tmp/2015-summary.json\").schema",
      "user": "anonymous",
      "dateUpdated": "Aug 5, 2018 4:33:09 PM",
      "config": {
        "colWidth": 12.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": true
        },
        "editorMode": "ace/mode/scala",
        "editorHide": false,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "res16: org.apache.spark.sql.types.StructType \u003d StructType(StructField(DEST_COUNTRY_NAME,StringType,true), StructField(ORIGIN_COUNTRY_NAME,StringType,true), StructField(count,LongType,true))\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533486708776_-613247354",
      "id": "20180805-163148_20770674",
      "dateCreated": "Aug 5, 2018 4:31:48 PM",
      "dateStarted": "Aug 5, 2018 4:32:50 PM",
      "dateFinished": "Aug 5, 2018 4:32:58 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\n- We can manually specify schema on a DataFrame\n- A schema is a StructType made up of a number of fields, StructFields, that have a name, type, a Boolean flag which specifies whether that column can contain missing or null values.\n- finally, users can optionally specify associated metadata with that column. The metadata is a way of storing information about this column",
      "user": "anonymous",
      "dateUpdated": "Aug 5, 2018 4:37:03 PM",
      "config": {
        "colWidth": 12.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": false,
        "tableHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cul\u003e\n\u003cli\u003eWe can manually specify schema on a DataFrame\u003c/li\u003e\n\u003c/ul\u003e\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533486769173_388562161",
      "id": "20180805-163249_1203930202",
      "dateCreated": "Aug 5, 2018 4:32:49 PM",
      "dateStarted": "Aug 5, 2018 4:35:57 PM",
      "dateFinished": "Aug 5, 2018 4:35:57 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "import org.apache.spark.sql.types.{StructField, StructType, StringType, LongType}\nimport org.apache.spark.sql.types.Metadata\n\nval myManualSchema \u003d StructType(Array(\n                        StructField(\"DEST_COUNTRY_NAME\", StringType, true),\n                        StructField(\"ORIGIN_COUNTRY_NAME\", StringType, true),\n                        StructField(\"count\", LongType, false, Metadata.fromJson(\"{\\\"hello\\\":\\\"world\\\"}\")))\n                        )\n                        \nval df \u003d spark.read.format(\"json\").schema(myManualSchema).load(\"/tmp/2015-summary.json\")\n",
      "user": "anonymous",
      "dateUpdated": "Aug 5, 2018 4:42:51 PM",
      "config": {
        "colWidth": 12.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false
        },
        "editorMode": "ace/mode/scala"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "import org.apache.spark.sql.types.{StructField, StructType, StringType, LongType}\nimport org.apache.spark.sql.types.Metadata\nmyManualSchema: org.apache.spark.sql.types.StructType \u003d StructType(StructField(DEST_COUNTRY_NAME,StringType,true), StructField(ORIGIN_COUNTRY_NAME,StringType,true), StructField(count,LongType,false))\ndf: org.apache.spark.sql.DataFrame \u003d [DEST_COUNTRY_NAME: string, ORIGIN_COUNTRY_NAME: string ... 1 more field]\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533486957216_1672725939",
      "id": "20180805-163557_1720946413",
      "dateCreated": "Aug 5, 2018 4:35:57 PM",
      "dateStarted": "Aug 5, 2018 4:42:51 PM",
      "dateFinished": "Aug 5, 2018 4:42:53 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\nThere are a lot of different ways to construct and refer to columns but the two simplest ways are by using the col or column functions. To use either of these functions, you pass in a column name:",
      "user": "anonymous",
      "dateUpdated": "Aug 5, 2018 4:43:27 PM",
      "config": {
        "colWidth": 12.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cp\u003eThere are a lot of different ways to construct and refer to columns but the two simplest ways are by using the col or column functions. To use either of these functions, you pass in a column name:\u003c/p\u003e\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533487085964_-1098266288",
      "id": "20180805-163805_1618676765",
      "dateCreated": "Aug 5, 2018 4:38:05 PM",
      "dateStarted": "Aug 5, 2018 4:43:27 PM",
      "dateFinished": "Aug 5, 2018 4:43:27 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "import org.apache.spark.sql.functions.{col, column}\ncol(\"someColumnName\")\ncolumn(\"someColumnName\")\n\ndf.col(\"count\")\ndf.columns\n",
      "user": "anonymous",
      "dateUpdated": "Aug 5, 2018 4:45:48 PM",
      "config": {
        "colWidth": 12.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false
        },
        "editorMode": "ace/mode/scala"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "import org.apache.spark.sql.functions.{col, column}\nres38: org.apache.spark.sql.Column \u003d someColumnName\nres39: org.apache.spark.sql.Column \u003d someColumnName\nres41: org.apache.spark.sql.Column \u003d count\nres42: Array[String] \u003d Array(DEST_COUNTRY_NAME, ORIGIN_COUNTRY_NAME, count)\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533487407520_-1660927355",
      "id": "20180805-164327_1121258320",
      "dateCreated": "Aug 5, 2018 4:43:27 PM",
      "dateStarted": "Aug 5, 2018 4:45:48 PM",
      "dateFinished": "Aug 5, 2018 4:45:49 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n### Expressions\n\n- An expression is a set of transformations on one or more values in a record in a DataFrame. \n- Think of it like a function that takes as input one or more column names, resolves them, and then potentially applies more expressions to create a single value for each record in the dataset.\n- Importantly, this “single value” can actually be a complex type like a Map or Array.\n\n\n",
      "user": "anonymous",
      "dateUpdated": "Aug 5, 2018 4:49:36 PM",
      "config": {
        "colWidth": 12.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003ch3\u003eExpressions\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eAn expression is a set of transformations on one or more values in a record in a DataFrame.\u003c/li\u003e\n\u003cli\u003eThink of it like a function that takes as input one or more column names, resolves them, and then potentially applies more expressions to create a single value for each record in the dataset.\u003c/li\u003e\n\u003cli\u003eImportantly, this “single value” can actually be a complex type like a Map or Array.\u003c/li\u003e\n\u003c/ul\u003e\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533487420839_-446828392",
      "id": "20180805-164340_135090293",
      "dateCreated": "Aug 5, 2018 4:43:40 PM",
      "dateStarted": "Aug 5, 2018 4:49:36 PM",
      "dateFinished": "Aug 5, 2018 4:49:36 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\n### Records and Rows\n\n- In Spark, each row in a DataFrame is a single record. Spark represents this record as an object of type Row. \n- Spark manipulates Row objects using column expressions in order to produce usable values.\n\n\nWe can also create DataFrames on the fly by taking a set of rows and converting them to a DataFrame\n",
      "user": "anonymous",
      "dateUpdated": "Aug 5, 2018 4:50:49 PM",
      "config": {
        "colWidth": 12.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003ch3\u003eRecords and Rows\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eIn Spark, each row in a DataFrame is a single record. Spark represents this record as an object of type Row.\u003c/li\u003e\n\u003cli\u003eSpark manipulates Row objects using column expressions in order to produce usable values.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe can also create DataFrames on the fly by taking a set of rows and converting them to a DataFrame\u003c/p\u003e\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533487776298_-32516768",
      "id": "20180805-164936_1225816640",
      "dateCreated": "Aug 5, 2018 4:49:36 PM",
      "dateStarted": "Aug 5, 2018 4:50:49 PM",
      "dateFinished": "Aug 5, 2018 4:50:49 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "import org.apache.spark.sql.Row\nimport org.apache.spark.sql.types.{StructField, StructType, StringType, LongType}\n\nval myManualSchema \u003d new StructType(Array(\n  new StructField(\"some\", StringType, true),\n  new StructField(\"col\", StringType, true),\n  new StructField(\"names\", LongType, false)))\n  \nval myRows \u003d Seq(Row(\"Hello\", null, 1L))\nval myRDD \u003d spark.sparkContext.parallelize(myRows)\nval myDf \u003d spark.createDataFrame(myRDD, myManualSchema)\nmyDf.show()\n",
      "user": "anonymous",
      "dateUpdated": "Aug 5, 2018 4:51:43 PM",
      "config": {
        "colWidth": 12.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "scala"
        },
        "editorMode": "ace/mode/scala"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "import org.apache.spark.sql.Row\nimport org.apache.spark.sql.types.{StructField, StructType, StringType, LongType}\nmyManualSchema: org.apache.spark.sql.types.StructType \u003d StructType(StructField(some,StringType,true), StructField(col,StringType,true), StructField(names,LongType,false))\nmyRows: Seq[org.apache.spark.sql.Row] \u003d List([Hello,null,1])\nmyRDD: org.apache.spark.rdd.RDD[org.apache.spark.sql.Row] \u003d ParallelCollectionRDD[46] at parallelize at \u003cconsole\u003e:56\nmyDf: org.apache.spark.sql.DataFrame \u003d [some: string, col: string ... 1 more field]\n+-----+----+-----+\n| some| col|names|\n+-----+----+-----+\n|Hello|null|    1|\n+-----+----+-----+\n\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533487849137_1439825328",
      "id": "20180805-165049_169006109",
      "dateCreated": "Aug 5, 2018 4:50:49 PM",
      "dateStarted": "Aug 5, 2018 4:51:43 PM",
      "dateFinished": "Aug 5, 2018 4:51:50 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "user": "anonymous",
      "config": {},
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "jobName": "paragraph_1533487903356_-649994130",
      "id": "20180805-165143_1432172023",
      "dateCreated": "Aug 5, 2018 4:51:43 PM",
      "status": "READY",
      "progressUpdateIntervalMs": 500
    }
  ],
  "name": "DataFrame_fundamental_operations",
  "id": "2DNJMUSM1",
  "angularObjects": {
    "2CHS8UYQQ:shared_process": [],
    "2C8A4SZ9T_livy2:shared_process": [],
    "2CK8A9MEG:shared_process": [],
    "2C4U48MY3_spark2:shared_process": [],
    "2CKAY1A8Y:shared_process": [],
    "2CKEKWY8Z:shared_process": []
  },
  "config": {
    "isZeppelinNotebookCronEnable": false
  },
  "info": {}
}